
# Golang 优雅处理错误,而不仅仅是检查

Go语言编程中,你是否在为了琳琅满目err不为nil而抗争,是否在为每个err都贴心的记录日志并返回.不偏不依,一错加两行。

这样的重复代码既不美观，又重复劳动，应该如何解决这个问题呢！

可惜没有单一的方法可以处理所有错误,但是Go的错误处理可以分为三个核心策略

## 1 Sentinel Error 预定义的哨兵机制

直接使用预定义的值来判断错误

```Golang
if err == ErrorSomething {
    ....
}
```

这是最不灵活的错误处理策略,因为调用方也必须使用相通的运算符将结果和预先声明的数值进行比较.且想提供更多错误上下文时会破坏相等性检查

如果同事要求你导出错误值,礼貌拒绝然后推荐后续两种方法吧!

## 2 Error type

```go
if err, ok := err.(SomeType); ok { … }
```

错误类型比错误值的最大改进是可以包装错误可以提供更多上下文,一个很好的例子是os.PathError.会注意尝试处理正在被调用文件的底层错误

但是这意味着错误类型必须公开,这个方法的所有调用者都必须依赖与定义错误类型的包,这会逐渐使API变得脆弱,所以也是尽量避免比较好

## 3 不透明错误处理

这应该是最灵活的错误处理逻辑,因为这样在业务代码和调用者之间耦合性最小

当你知道了发生了错误时,无法查看错误内部,仅知道该操作结果是否有效

这就是不透明错误处理的全部,仅返回错误而无需假设内容

```go
import “github.com/quux/bar”

func fn() error {
        x, err := bar.Foo()
        if err != nil {
                return err
        }
        // use x
}
```

例如Foo不保证在错误时会返回什么.但是现在Foo可以通过注释虽已通过附加上下文来传递错误,而不会破坏与调用者的约定。




## Indented flow is for errors

首先无错误的正常流程代码,将成为一条直线,而不是缩进的代码

P25

## Wrap errors

我们经常发现类似的代码,在错误处理中,带有两个任务,记录日志并再次返回错误,感觉很冗余却又无可奈何?

## handler errors

我们只应该处理错误以此.处理一个错误意味着

log.Println(...)

return err

在自己的应用代码中,适应e.New()或e.Errorf()返回错误

和其他库协同合作考虑e.Wrap或e.Wrapf保存堆栈信息。同样适用于和标准库协作

直接返回错误而不是每个错误产生的地方到处打印日志



尽可能避免Sentinel Error

